## Table of Contents
- [appwindowprofiler_gl.hpp](#appwindowprofiler_glhpp)
- [contextwindow_gl.hpp](#contextwindow_glhpp)
- [error_gl.hpp](#error_glhpp)
- [extensions_gl.hpp](#extensions_glhpp)
- [profiler_gl.hpp](#profiler_glhpp)
- [programmanager_gl.hpp](#programmanager_glhpp)

## appwindowprofiler_gl.hpp
### class nvgl::AppWindowProfilerGL

nvgl::AppWindowProfilerGL derives from nvh::AppWindowProfiler
and overrides the context and swapbuffer functions.

To influence the context creation modify
`m_contextInfo` prior running AppWindowProfiler::run,
which triggers window, and context creation etc.

The class comes with a nvgl::ProfilerGL instance that references the
AppWindowProfiler::m_profiler's data.

## contextwindow_gl.hpp
### struct nvgl::ContextWindowCreateInfo

Set up the context properties for a OpenGL ContextWindow.
e.g. version, core/compatibiltiy etc.
### class nvgl::ContextWindow

nvgl::ContextWindow sets up an OpenGL context from a provided `GLFWwindow`.
Makes use of `glDebugMessageCallback` to hook up an error callback
and loads all extensions provided by `extensions_gl.hpp`

## error_gl.hpp
### functions in nvgl

Several utility functions that aid debugging. Check if all bindings
are cleared, framebuffer complete etc.
### template class nvgl::CheckBufferContent
Utility wrapper to downlad buffer data into a temp vector for debugging
### class nvgl::CheckBufferResidency
nvgl::CheckBufferResidency utility class to test if a certain gpu address is coming from
a resident buffer. Register the address of buffers in advance.

## extensions_gl.hpp
### function load_GL
> An OpenGL Extension loader

  Provides a subset of OpenGL Extensions generated by `extensions_gl.lua`.
  The framework uses a sanitized OpenGL header that is mostly core functionality.
  `GL/glsubset.h` is generated using a enablelist by the lua script
  from `GL/glcustom.h` (which is mostly based on `glcorearb.h` with some
  additional extensions and features)

## profiler_gl.hpp
### class nvgl::ProfilerGL

nvgl::ProfilerGL extends Profiler and uses `glQueryCounter(... GL_TIMESTAMP)`
to compute the GPU time of a section.
`glPushDebugGroup` and `glPopDebugGroup` are used within each timed
section, so that the section names can show up in NSightGraphics,
renderdoc or comparable tools.


## programmanager_gl.hpp
### class nvgl::ProgramManager

The nvgl::ProgramManager manages OpenGL programs generated from shader files (GLSL)

Using ShaderFileManager it will find the files and resolve #include for GLSL.
You must add include directories to the base-class for this.

It also comes with some convenience functions to reload shaders etc.
That is why we pass out the ProgramID rather than a GLuint directly.

Example:

```cpp
ProgramManager mgr;

// derived from ShaderFileManager
mgr.addDirectory("/shaders/")

// injected after #version directive
mgr.m_prepend = "#define USE_NOISE 1\n";

id = mgr.createProgram({{GL_VERTEX_SHADER, "object.vert.glsl"},{GL_FRAGMENT_SHADER, "object.frag.glsl"}}):

glUseProgram(mgr.get(id));
```
